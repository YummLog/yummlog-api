// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createFoodPost = `-- name: CreateFoodPost :one
insert into foodposts(
    id,
    restaurant_name,
    address1,
    address2,
    city,
    state,
    country,
    zipcode,
    user_id,
    created_by,
    created_date,
    updated_by,
    updated_date,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) returning id, restaurant_name, address1, address2, city, state, country, zipcode, user_id, created_by, created_date, updated_by, updated_date, notes
`

type CreateFoodPostParams struct {
	ID             string
	RestaurantName string
	Address1       sql.NullString
	Address2       sql.NullString
	City           sql.NullString
	State          sql.NullString
	Country        sql.NullString
	Zipcode        sql.NullString
	UserID         sql.NullString
	CreatedBy      sql.NullString
	CreatedDate    sql.NullTime
	UpdatedBy      sql.NullString
	UpdatedDate    sql.NullTime
	Notes          sql.NullString
}

func (q *Queries) CreateFoodPost(ctx context.Context, arg CreateFoodPostParams) (Foodpost, error) {
	row := q.db.QueryRowContext(ctx, createFoodPost,
		arg.ID,
		arg.RestaurantName,
		arg.Address1,
		arg.Address2,
		arg.City,
		arg.State,
		arg.Country,
		arg.Zipcode,
		arg.UserID,
		arg.CreatedBy,
		arg.CreatedDate,
		arg.UpdatedBy,
		arg.UpdatedDate,
		arg.Notes,
	)
	var i Foodpost
	err := row.Scan(
		&i.ID,
		&i.RestaurantName,
		&i.Address1,
		&i.Address2,
		&i.City,
		&i.State,
		&i.Country,
		&i.Zipcode,
		&i.UserID,
		&i.CreatedBy,
		&i.CreatedDate,
		&i.UpdatedBy,
		&i.UpdatedDate,
		&i.Notes,
	)
	return i, err
}

const createPostDetails = `-- name: CreatePostDetails :one
insert into postdetails(
    id,
    post_id,
    item,
    experience
) values ($1, $2, $3, $4) returning id, post_id, item, experience
`

type CreatePostDetailsParams struct {
	ID         string
	PostID     string
	Item       string
	Experience string
}

func (q *Queries) CreatePostDetails(ctx context.Context, arg CreatePostDetailsParams) (Postdetail, error) {
	row := q.db.QueryRowContext(ctx, createPostDetails,
		arg.ID,
		arg.PostID,
		arg.Item,
		arg.Experience,
	)
	var i Postdetail
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.Item,
		&i.Experience,
	)
	return i, err
}

const listFoodPosts = `-- name: ListFoodPosts :many
SELECT fp.id, restaurant_name, address1, address2, city, state, country, zipcode, user_id, created_by, created_date, updated_by, updated_date, notes, pd.id, post_id, item, experience
FROM foodposts fp join postdetails pd on fp.id = pd.post_id
`

type ListFoodPostsRow struct {
	ID             string
	RestaurantName string
	Address1       sql.NullString
	Address2       sql.NullString
	City           sql.NullString
	State          sql.NullString
	Country        sql.NullString
	Zipcode        sql.NullString
	UserID         sql.NullString
	CreatedBy      sql.NullString
	CreatedDate    sql.NullTime
	UpdatedBy      sql.NullString
	UpdatedDate    sql.NullTime
	Notes          sql.NullString
	ID_2           string
	PostID         string
	Item           string
	Experience     string
}

func (q *Queries) ListFoodPosts(ctx context.Context) ([]ListFoodPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFoodPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFoodPostsRow
	for rows.Next() {
		var i ListFoodPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantName,
			&i.Address1,
			&i.Address2,
			&i.City,
			&i.State,
			&i.Country,
			&i.Zipcode,
			&i.UserID,
			&i.CreatedBy,
			&i.CreatedDate,
			&i.UpdatedBy,
			&i.UpdatedDate,
			&i.Notes,
			&i.ID_2,
			&i.PostID,
			&i.Item,
			&i.Experience,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostDetails = `-- name: ListPostDetails :many
SELECT id, post_id, item, experience
FROM postdetails
`

func (q *Queries) ListPostDetails(ctx context.Context) ([]Postdetail, error) {
	rows, err := q.db.QueryContext(ctx, listPostDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Postdetail
	for rows.Next() {
		var i Postdetail
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.Item,
			&i.Experience,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
